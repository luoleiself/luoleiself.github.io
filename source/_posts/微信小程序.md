---
title: 微信小程序
date: 2021-12-24 11:54:05
categories:
  - wx
tags:
  - wx
---

### 敲黑板

#### 地理位置

##### [地理位置 API 调整](https://developers.weixin.qq.com/community/develop/doc/000a02f2c5026891650e7f40351c01?blockType=1)

- 20220628 起, 使用地理位置 API 需要在 app.json 配置项 requirePrivateInfos 提前声明

```json
{ "requirePrivateInfos": ["chooseAddress", "getFuzzyLocation"] }
```

- 部分 API 需要在管理后台申请接口权限

![wx-1](/images/wx-1.png)

##### [接口权限申请](https://developers.weixin.qq.com/community/develop/doc/000e8ccb5ac498318cbd26c495bc01?blockType=1)

- getFuzzyLocation
- getLocation
- onLocationChange
- chooseAddress
- choosePoi
- chooseLocation

- 20220418 起, 如果使用以上接口, 需要在小程序管理后台申请接口权限
- 地理位置新增接口和相关流程调整

##### [choosePoi|chooseLocation](https://developers.weixin.qq.com/community/develop/doc/0006e45df2cac030e6edf367c56001?blockType=1)

- 20220613 起, 使用该接口不在需要用户授权 scope.userLocation
- wx.choosePoi 回调信息中不再返回真实的经纬度信息, 全部返回(0,0)

##### [getFuzzyLocation](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.chooseLocation.html)

- 2.25.0 开始, 新增获取模糊地理位置接口, 接口规则同 [chooseLocation](https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.chooseLocation.html)

#### [getPhoneNumber](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/phonenumber/phonenumber.getPhoneNumber.html)

- e.detail.code 只在真机调试中才会返回,通过此码可以获取微信绑定的手机号
- e.detail.iv
- e.detail.encryptedData

#### [wx.openSetting](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.openSetting.html)

- 2.3.0 开始, [打开小程序设置页](https://developers.weixin.qq.com/community/develop/doc/000cea2305cc5047af5733de751008) 改为用户行为触发, 直接调用此 API 无效

```html
<!-- 方法一 -->
<button open-type="openSetting" bindopensetting="callback">打开设置页</button>
<!-- 方法二 -->
<button bindtap="openSetting">打开设置页</button>
openSetting(){ wx.openSetting() }
```

#### [behaviors](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)

- 自定义组件混入 behaviors, 在 attached 钩子函数中调用混入的方法获取不到, 需要在 ready 中调用

#### ios 微信小程序 input 输入框使用 bind:focus 时, 在 input 获取焦点后会出现输入法键盘,然后点击其他下拉框或自定义组件会出现 input 仍然可以编辑状态

- 修改 input 的 focus 属性

#### 小程序多 appId 平台提审和接口域名切换

使用以下 API 获取小程序 appId, 根据 appid 推送不同平台和切换不同接口域名

- [wx.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 获取小程序启动时的参数, 与 App.onLaunch 的回调参数一致
  - 2.1.2 支持
- [wx.getAccountInfoSync](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/account-info/wx.getAccountInfoSync.html) 获取当前帐号信息, 线上小程序版本号仅支持在正式版小程序中获取, 开发版和体验版中无法获取
  - 2.2.2 支持

<!-- more -->

#### 单页应用添加微信分享打包后分享时好好坏

- [企微](https://developer.work.weixin.qq.com/document/path/90542) 微信 JSSDK 签名的 url 和当前显示的 url 不一致导致自定义分享信息失败,在路由钩子函数或者监听路由变化时重新请求接口签名
- [微信](https://developers.weixin.qq.com/community/develop/doc/000088945c4320dae71d677d15b400?jumpto=reply&parent_commentid=000062cf8fcaf80be71d58bd15b4&commentid=000a68a75ac9188cf81d2be8353c) 微信中打开普通 URL 链接分享仍为普通 URL 链接, 卡片形式的链接不受此影响

#### 小程序内嵌 H5 页区分运行环境

小程序内嵌 H5 页区分运行环境是小程序还是 H5 执行不同逻辑调用 wx.miniProgram.getEnv 依赖微信 JSSDK 1.4 以上版本, 微信 JSSDK 1.0 报错

```javascript
var ua = navigator.userAgent.toLowerCase();
var result = ua.match(/MicroMessenger/i);
if (result && result[0] == `micromessenger`) {
  //ios的ua中无miniProgram，但都有MicroMessenger（表示是微信浏览器）
  wx.miniProgram.getEnv(function (res) {
    if (res.miniprogram) {
      // 小程序内
    } else {
      // 非小程序内
    }
  });
} else {
  // 非小程序内
}
```

### 逻辑层

#### [注册页面](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)

- 2.9.2 支持 `behaviors` 配置项, 使多个页面可以共享相同的数据和方法

```javascript
// my-behavior.js
module.exports = Behavior({
  data: {},
  methods: {
    sharedMethod: function () {
      this.data.sharedText === 'This is a piece of data shared between pages.';
    },
  },
});
// page-a.js
const myBehaviors = require('./my-behavior.js');
Page({
  behaviors: [myBehaviors],
  onLoad() {
    this.data.sharedText === 'This is a piece of data shared between pages.';
  },
});
```

#### [API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#API)

- 2.10.2 支持 callback 和 promise 两种调用方式. 接口参数 Object 对象不包含 success/fail/complete 时默认返回 promise, 否则按回调方式执行,无返回值

### 视图层

#### [WXML](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/)

- dataset 自定义数据以 `data-` 开头, 多个单词使用连字符 `-` 连接, 此写法会被自动转换成驼峰写法, 大写字符会自动转换成小写字符

```javascript
data-element-type /* 最终会呈现为 */ event.currentTarget.dataset.elementType
data-elementType /* 最终会呈现为 */ event.currentTarget.dataset.elementtype

// vue自定义事件绑定使用 kebab-case 写法
v-bind:my-event
```

- 2.9.3 支持简易双向绑定 `model:property="{{myProperty}}"`

#### [事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)

- 1.5.0 支持事件捕获阶段, 可使用 `capture-bind`, `capture-catch` 关键字

```html
<!-- 执行顺序: handleTap2、handleTap4、handleTap3、handleTap1 -->
<!-- 如果将第一个 capture-bind 改为 capture-catch，将只触发 handleTap2  -->
<view
  id="outer"
  bind:touchstart="handleTap1"
  capture-bind:touchstart="handleTap2"
>
  outer view
  <view
    id="inner"
    bind:touchstart="handleTap3"
    capture-bind:touchstart="handleTap4"
  >
    inner view
  </view>
</view>
```

- 2.4.4 支持 [WXS 函数响应事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html)
- 2.8.1 支持所有组件 `bind:event_name` 事件绑定方式
- 2.8.2 支持 `mut-bind` 事件绑定, 所有 `mut-bind` 之间是"互斥"的, 只会有其中一个绑定函数被触发, 同时,不会影响到 `bind` 和 `catch` 的绑定效果

```html
<!-- 点击 inter view 会依次调用 handleTap3、handleTap2 -->
<!-- 点击 middle view 会依次调用 handleTap2、handleTap1 -->
<view id="outer" mut-bind:tap="handleTap1">
  outer view
  <view id="middle" bind:tap="handleTap2">
    middle view
    <view id="inner" mut-bind:tap="handleTap3"> inner view </view>
  </view>
</view>
```

#### [响应显示区域](https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html)

- 2.4.0 支持屏幕旋转, 可配置全局或者页面的屏幕旋转

```json
{ "pageOrientation": "auto" }
```

- 2.5.0 支持 `pageOrientation` 设置为 `landscape` 表示为固定横屏显示
- 2.3.0 支持 iPad 小程序屏幕旋转, `仅支持`在 app.json 中配置

```json
{ "resizable": true }
```

- 2.4.0 支持页面 `resize` 生命周期监听页面显示区域变化
- windows wx 3.3 支持小程序`分栏模式`, 在 app.json 中配置

```json
{ "resizable": true, "frameset": true }
```

#### [动画](https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html)

- 2.9.0 支持[关键帧动画](https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html)代替旧的 `wx.createAnimation`

```javascript
// selector String, required, 选择器
// keyframes Array, required, 关键帧信息
// duration Number, required, 动画持续时长(单位毫秒)
// callback function, not required, 动画完成后的回调
this.animate(selector, keyframes, duration, callback);
// 清楚动画执行完毕后的属性
this.clearAnimation(selector, options, callback);
```

#### [初始渲染缓存](https://developers.weixin.qq.com/miniprogram/dev/framework/view/initial-rendering-cache.html)

- 2.11.1 支持

  - 支持的内置组件
    - view
    - text
    - button
    - image
    - scroll-view
    - rich-text
  - 启用初始化渲染缓存指定页面,在 `页面.json` 配置文件中配置, 不包含任何 `setData` 的结果

  ```json
  { "initialRenderingCache": "static" }
  ```

  - 缓存所有页面, 在 `app.json` 中配置

  ```json
  {
    "window": {
      "initialRenderingCache": "static"
    }
  }
  ```

- 初始渲染缓存页面中添加动态内容, `页面.json` 配置文件

  - 此方法调用不能早于 `Page` 的 `onReady` 或者 `Component` 的 `ready` 生命周期, 否则影响性能
  - 参数传入 `null` 可禁用初始渲染缓存

```json
{ "initialRenderingCache": "dynamic" }
```

```javascript
<view wx:if='{{loading}}'>{{ loadingHint }}</view>;
// 页面中调用此方法启用
Page({
  data: {
    loading: true,
  },
  onReady: function () {
    // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData
    this.setInitialRenderingCache({ loadingHint: '正在加载' });
  },
});
```

### 运行

#### [运行机制](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html)

- 前台进入后台 `5秒` 后进入挂起状态, 小程序代码停止运行
- 挂起状态维持 `30分钟` 后会被销毁, 如果小程序占用系统资源过高,可能会被系统销毁或者微信客户端主动回收

#### 重新启动策略

- 2.8.0 支持如果冷启动时不带`path`参数, 默认进入小程序的首页, 在 `页面.json` 或者 `app.json` 修改小程序冷启动时的默认行为

  - 如果小程序退出时间过久 `1天`, 下次冷启动时不遵循此规则

```json
/* homePageAndLatestPage */
//如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）
{ "restartStrategy": "homePage" }
```

#### 退出状态

小程序可能被销毁之前, 页面回调函数 `onSaveExitState` 会被调用, 如果需要保留页面页面中的状态, 可以在这个回调函数中保存一些数据, 下次启动时可以通过 `exitState` 获得已保存得数据, 如果小程序退出时间过久`1天`会丢弃保存的数据

- 2.7.4 支持

```json
{ "restartStrategy": "homePageAndLatestPage" }
```

```javascript
Page({
  onLoad: function () {
    // 尝试获得上一次退出前 onSaveExitState 保存的数据
    var prevExitState = this.exitState;
    if (prevExitState !== undefined) {
      // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
      prevExitState.myDataField === 'myData';
    }
  },
  onSaveExitState: function () {
    var exitState = { myDataField: 'myData' }; // 需要保存的数据
    return {
      data: exitState,
      // 超时时刻, 默认:当前时间 + 1天
      expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000,
    };
  },
});
```

### 自定义组件

- 1.6.3 支持

#### [构造器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html)

- behaviors
  - 自定义组件引入的 behaviors 定义的方法在 attached 钩子函数中获取不到，需要在 ready 中调用
- properties
  - 配置项中使用驼峰写法(propertyName), 在 xml 文件中使用连字符写法(property-name)
- data
- methods
- relations 组件关系定义
- externalClasses
- options
- this.selectComponent() 父组件中获取子组件实例对象
- triggerEvent 触发事件
- 生命周期
  - lifetimes 2.2.3 支持, 优先级最高会覆盖外部定义的生命周期钩子
    - created 在组件实例刚刚被创建时执行，注意此时不能调用 setData
    - attached 在组件实例进入页面节点树时执行, 大部分初始化工作可以在此方法内执行
    - ready 在组件布局完成后执行
    - moved 在组件实例被移动到节点树另一个位置时执行
    - detached 在组件实例被从页面节点树移除时执行)
  - pageLifetimes 组件所在页面的生命周期
    - show 组件所在的页面被展示时执行
    - hide 组件所在的页面被隐藏时执行
    - resize 组件所在的页面尺寸变化时执行

#### [引用](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

- 在 `页面.json` 文件中配置

```json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```

- 页面

```html
<view>
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text"></component-tag-name>
</view>
```

#### [模板和样式](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)

- slot

  - 开启多个 slot

  ```javascript
  Component({
    options: {
      multipleSlots: true, // 在组件定义时的选项中启用多slot支持
    },
    properties: {},
    methods: {},
  });
  ```

  ```html
  <!-- 组件模板 -->
  <view class="wrapper">
    <slot name="before"></slot>
    <view>这里是组件的内部节点</view>
    <slot name="after"></slot>
  </view>
  <!-- 引用组件的页面模板 -->
  <view>
    <component-tag-name>
      <view slot="before">这里是插入到组件slot-before中的内容</view>
      <view slot="after">这里是插入到组件slot-after中的内容</view>
    </component-tag-name>
  </view>
  ```

- 组件样式隔离, 避免组件内部使用的`标签下选择器样式`污染页面

  - 2.6.5 支持 `js` 中配置

  ```javascript
  Component({
    options: { styleIsolation: 'isolated' },
  });
  ```

  - 2.10.1 支持在 `页面.json` 或者 `自定义组件.json` 中配置

  ```json
  { "styleIsolation": "isolated" }
  ```

- 外部样式应用

  - 1.9.90 支持
  - 2.7.1 支持多个 `class`

  ```javascript
  /* 组件 custom-component.js */
  Component({
    externalClasses: ['my-class'],
  });
  ```

  ```html
  <!-- 组件 custom-component.wxml -->
  <custom-component class="my-class"
    >这段文本的颜色由组件外的 class 决定</custom-component
  >
  ```

#### [behaviors](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)

- 内置 behaviors

  - wx://form-field
  - wx://form-field-group 2.10.2 支持
  - wx://form-field-button 2.10.3 支持
  - wx://component-export 2.2.3 支持

- 同名字段覆盖和组合规则
  - 同名属性和方法
    - 组件本身的属性和方法覆盖 behavior 中的
    - behavior 中定义靠后的覆盖靠前的
    - 嵌套引用 behavior 的情况, 父 behavior 覆盖子 behavior 中
  - 同名数据字段
    - 对象类型进行对象合并
    - 其余情况进行数据覆盖: 组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior
  - 生命周期钩子不会覆盖,逐个调用
    - behavior 优先于组件执行
    - 子 behavior 优先于 父 behavior 执行
    - 靠前的 behavior 优先于 靠后的 behavior 执行
    - 多次引用 behavior, 生命周期只会被执行一次
- 2.15.0 [behaviors 中声明的生命周期钩子会被 Page 和 Component 构造器中声明的同名钩子覆盖执行, 和上面文档中描述的不一样](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)

#### [组件之间关系](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/relations.html)

- type 目标组件的相对关系
  - parent
  - child
  - ancestor
  - descendant
- linked 生命周期钩子, 当关系被建立在页面节点树中时触发，触发时机在组件 attached 生命周期之后
- linkChanged 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件 moved 生命周期之后
- unlinked 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件 detached 生命周期之后
- target 关联的目标节点所应具有的 behavior，所有拥有这一 behavior 的组件节点都会被关联

```html
<custom-ul>
  <custom-li> item 1 </custom-li>
  <custom-li> item 2 </custom-li>
</custom-ul>
```

```js
// path/to/custom-ul.js
Component({
  relations: {
    './custom-li': {
      type: 'child', // 关联的目标节点应为子节点
      linked: function (target) {
        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function (target) {
        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function (target) {
        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      },
    },
  },
  methods: {
    _getAllLi: function () {
      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('path/to/custom-li');
    },
  },
  ready: function () {
    this._getAllLi();
  },
});
// path/to/custom-li.js
Component({
  relations: {
    './custom-ul': {
      type: 'parent', // 关联的目标节点应为父节点
      linked: function (target) {
        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function (target) {
        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function (target) {
        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      },
    },
  },
});
```

#### [数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html)

用于监听和响应任何属性和数据字段的变化,作用类似于计算属性

- 2.6.1 支持

```javascript
// this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和
Component({
  attached: function () {
    this.setData({ numberA: 1, numberB: 2 });
  },
  observers: {
    'numberA, numberB': function (numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({ sum: numberA + numberB });
    },
  },
});
```

#### [纯数据字段](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html)

- 纯数据字段是一些不用于界面渲染的 data 字段(包括 setData 设置的字段), 既不会展示在界面上,也不会传递给其他组件，可以用于提升页面更新性能

- 属性中的纯数据字段的属性不会触发 observer, 需要使用 observers([数据监听器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html)) 监听

- 2.8.2 支持

```javascript
Component({
  options: {
    pureDataPattern: /^_/, // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
});
```

- 2.10.1 支持在 json 配置文件中配置 pureDataPattern 项

#### [抽象节点](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/generics.html)

自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”

- 1.9.6 支持

```html
<!-- generic-node.wxml -->
<view>
  <generic-node></generic-node>
</view>

<!-- 使用 -->
<!-- 自定义单选框 -->
<selectable-group generic:generic-node="custom-radio" />
<!-- 自定义复选框 -->
<selectable-group generic:generic-node="custom-checkbox" />
```

```json
{
  "componentGenerics": {
    "generic-node": true /* 在 componentGenerics 中声明抽象节点*/
  },
  "usingComponents": {
    "custom-radio": "path/to/custom/radio",
    "custom-checkbox": "path/to/custom/checkbox"
  }
}
```

#### [自定义组件扩展](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/extend.html)

- 2.2.3 支持, 详细用法看文档

#### [开发第三方自定义组件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/trdparty.html)

- 2.2.1 支持

#### [单元测试](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/unit-test.html)

- 2.2.1 支持

#### [获取更新性能统计信息](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/update-perf-stat.html)

- 2.12.0 支持

#### [占位组件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/placeholder.html)

在使用 [分包异步化](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html) 或 用时注入 等特性时, 不可用的自定义组件使用 占位组件 临时替代渲染

- 2.17.3 支持

```json
{
  "componentPlaceholder": {
    "comp-a": "view",
    "comp-b": "comp-c"
  }
}
```

### 插件

### 基础能力

### 连接硬件能力

### 开放能力
